---
title: "Datakit"
author: "Sandra FudorovÃ¡"
format: html
editor: visual
---

# DataKit

This script serves as a utilities package to be used during data cleaning and analysis. It introduces necessary functions to simplify workflow and increase the efficiency of our work.

# 1. Data Cleaning and Pre-processing

## 1.1 Outlier Detection Function

**What it does:**

This function is used to identify and replace all values in select variables that are further away than three standard deviations from the mean. The **x** parameter is the variables the function will be applied to and **replacement** specifies what value they will be replaced by.

**Function:**

```{r}
outlier_detection <- function(x, replacement) {
  ifelse(
    x > (mean(x, na.rm = TRUE) + 3 * sd(x, na.rm = TRUE)) | 
    x < (mean(x, na.rm = TRUE) - 3 * sd(x, na.rm = TRUE)),
    replacement,  # Replace outliers
    x       # Keep non-outlier values
  )
}
```

## 1.2 Replace Placeholders

**What it does:** Replaces select placeholders with missing values after the outlier analysis.

*Parameters:*

-   **data:** The dataset

-   **numeric_values:** a vector of possible placeholders in numeric variables.

-   **character_values:** a vector of possible placeholders in character variables.

```{r}
replace_placeholders <- function(data,
                                 numeric_values = c(9999, 9998, 9997),
                                 character_values = c("i don't know", "i prefer not to say", "9999", "9998")) {

  total_replacements <- 0

  # Replace numeric placeholders
  for (val in numeric_values) {
    before <- sum(data[sapply(data, is.numeric)] == val, na.rm = TRUE)
    data <- data %>%
      mutate(across(where(is.numeric), ~na_if(., val)))
    total_replacements <- total_replacements + before
  }

  # Replace character placeholders (case-insensitive match, but retain original case)
  char_cols <- which(sapply(data, is.character))

  for (col_index in char_cols) {
    col_name <- names(data)[col_index]
    original_col <- data[[col_name]]
    lower_col <- tolower(original_col)

    is_match <- lower_col %in% tolower(character_values)
    total_replacements <- total_replacements + sum(is_match, na.rm = TRUE)

    data[[col_name]][is_match] <- NA
  }

  message(sprintf("\n \n Replaced %d placeholder values with NA", total_replacements))
  return(data)
}

```

## 1.3 Standard Data Cleaning

**What it does:** This function carries out standard data cleaning, that is to be done at the beginning of data processing.

*The parameters:*

-   **data:** The dataset

-   **irrelevant_columns**: Columns to be removed such as deviceid

-   **deduplicate_by**: Column that is to be checked for duplicates. The column selected here should be the unique identifier such as uuid.

*Once passed, it:*

-   Reformats submission date to correct format

-   Removes irrelevant columns (if selected)

-   Renames columns to lower case

-   Removes completely empty columns

-   Removes farmers who did not agree to participate

-   Removes duplicate entries

**Function:**

```{r}
clean_raw_data <- function(data, irrelevant_columns = NULL, deduplicate_by = NULL) {
  cleaned <- data %>%
    # Convert submissiondate to Date format
    mutate(submissiondate = as.Date(submissiondate, format = "%d-%m-%Y")) %>%
    
    # Remove specified irrelevant columns (if provided)
    { if (!is.null(irrelevant_columns)) select(., -all_of(irrelevant_columns)) else . } %>%
    
    # Convert all column names to lowercase
    rename_with(tolower) %>%
    
    # Keep only farmers marked as "accepted to participate"
    filter(tolower(farmer_present) == "accepted to participate") %>%
    
    # Remove completely empty columns
    select(where(~ !all(is.na(.))))
  
  # Deduplication (if requested)
  if (!is.null(deduplicate_by) && deduplicate_by %in% colnames(cleaned)) {
    duplicated_rows <- cleaned %>%
      filter(duplicated(.data[[deduplicate_by]]))
    
    if (nrow(duplicated_rows) > 0) {
      message(sprintf("Removed %d duplicate row(s) based on '%s'.", 
                      nrow(duplicated_rows), deduplicate_by))
      message("Duplicate values removed: ", 
              paste(unique(duplicated_rows[[deduplicate_by]]), collapse = ", "))
    }
    
    cleaned <- cleaned %>%
      distinct(across(all_of(deduplicate_by)), .keep_all = TRUE)
  }
  
  return(cleaned)
}

```

## 1.4 Merging "other" Variables

**What it does:** Combines all columns that store answers to "Other, please specify" questions with the parent variable. The name of the variable kept is the parent name. In case there is an "other" column with a missing parent, the function throws an error message.

*The parameters:*

-   **data:** a dataset

-   **include_premium:** in some cases there is no premium price data, so this parameter (default = TRUE) can exclude it from analysis, preventing the function from breaking.

```{r}
merge_other <- function(data) {
  variables_other <- data %>%
    select(ends_with("_other"), ends_with("_other2")) %>%
    names()

  for (other in variables_other) {
    parent <- gsub("_other$|_other2$", "", other)

    if (parent %in% names(data)) {
      new_col <- sym(parent)

      data <- data %>%
        unite(
          !!new_col,
          all_of(c(parent, other)),
          sep = " | ",
          remove = FALSE,
          na.rm = TRUE
        ) %>%
        select(-all_of(other))
    } else {
      warning(sprintf("No matching parent column found for '%s'", other))
    }
  }

  return(data)
}

```

## 1.5 Correct Quantities

When production and sale volumes are 0, we want all volume related indicators to be NA as these are not the farmers to be included in further analyses.

**What it does:** Replaces values as NA across \_prod, \_sold, \_lost, and *\_*sold_premium.

**Par**

```{r}
correct_quantities <- function(data, include_premium = TRUE) {
  data <- data %>%
    mutate(
      changed_prod = f_focus_quant_prod == 0 & f_focus_quant_sold == 0,
      changed_sold = f_focus_quant_prod == 0 & f_focus_quant_sold == 0,
      changed_lost = f_focus_quant_prod == 0 & f_focus_quant_sold == 0,

      f_focus_quant_prod = ifelse(changed_prod, NA, f_focus_quant_prod),
      f_focus_quant_sold = ifelse(changed_sold, NA, f_focus_quant_sold),
      f_focus_quant_lost = ifelse(changed_lost, NA, f_focus_quant_lost)
    )

  message(sprintf("Changed %d values in f_focus_quant_prod", sum(data$changed_prod, na.rm = TRUE)))
  message(sprintf("Changed %d values in f_focus_quant_sold", sum(data$changed_sold, na.rm = TRUE)))
  message(sprintf("Changed %d values in f_focus_quant_lost", sum(data$changed_lost, na.rm = TRUE)))

  if (include_premium) {
    data <- data %>%
      mutate(
        f_focus_quant_sold_premium = ifelse(f_focus_quant_prod == 0 & f_focus_quant_sold == 0, 
                                            NA, f_focus_quant_sold_premium)
      )
    message(sprintf("Changed %d values in f_focus_quant_sold_premium", sum(data$changed_premium, na.rm = TRUE)))
    data <- data %>% select(-changed_premium)
  }

  data <- data %>% select(-changed_prod, -changed_sold, -changed_lost)

  return(data)
}
```

## 1.6 Variable Check

**What it does:** This function serves as an easy check for any variables that are being cleaned. There is an option for numerical variables and for categorical variables.

**Numerical Variables**

*The parameters:*

-   **data:** the dataset

-   **var:** the variable

-   **show_plot:** determinant of whether the function also creates a histogram, the default is yes.

-   **bins:** manual adjustment to the bin size in a histogram. The default is none and the function includes a method to find the best bin size.

*For numerical variables, the function provides:*

-   A **summary** statistics of the variable

-   The number of **missing** values

-   The number of **unique** values

-   The percentage of 0s

-   A histogram of the variable

```{r}
check_num_variable <- function(data, var, show_plot = TRUE, bins = NULL) {
  var_sym <- rlang::ensym(var)
  var_name <- rlang::as_name(var_sym)
  x <- data[[var_name]]
  
  if (!is.numeric(x)) {
    stop(paste(var_name, "is not numeric."))
  }

  if (all(is.na(x))) {
    cat("All values in", var_name, "are NA.\n")
    return(invisible(NULL))
  }
  
  cat("Variable:", var_name, "\n\n")
  
  cat("ðŸ“Š Summary Statistics:\n")
  print(summary(x))
  
  cat("\nâ“ Missing values:", sum(is.na(x)), "\n")
  cat("ðŸ”¢ Unique values:", length(unique(x)), "\n")
  cat("ðŸŸ¡ Percentage of zero values:", round(mean(x == 0, na.rm = TRUE) * 100, 2), "%\n\n")
  
  if (show_plot) {
    # Determine bins automatically if not provided
    if (is.null(bins)) {
      iqr <- IQR(x, na.rm = TRUE)
      n <- sum(!is.na(x))
      bin_width <- 2 * iqr / (n^(1/3))
      bins <- if (bin_width > 0) ceiling((max(x, na.rm = TRUE) - min(x, na.rm = TRUE)) / bin_width) else 30
    }
    
    cat("ðŸ“ˆ Histogram:\n")
    print(
      ggplot(data, aes(x = !!var_sym)) +
        geom_histogram(bins = bins, fill = "skyblue", color = "black") +
        labs(title = paste("Histogram of", var_name), x = var_name, y = "Count") +
        theme_minimal()
    )
  }
}

```

**Categorical Variables**

*The parameters:*

-   **data:** the dataset

-   **var:** the variable

-   **show_plot:** determinant of whether the function also creates a histogram, the default is yes.

*For numerical variables, the function provides:*

-   A **frequency table**

-   The number of **missing** values

-   The number of **unique** values

-   A **bar** chart that will show the top 10 answers

```{r}
check_cat_variable <- function(data, var, show_plot = TRUE) {
  var_sym <- rlang::ensym(var)
  var_name <- rlang::as_name(var_sym)
  x <- data[[var_name]]
  
  if (!is.character(x) && !is.factor(x)) {
    stop(paste(var_name, "is not a character or factor variable."))
  }
  
  cat("ðŸ”Ž Variable:", var_name, "\n\n")
  
  # Frequency table
  freq_table <- table(x, useNA = "ifany") %>% sort(decreasing = TRUE)
  print(freq_table)
  
  cat("\nâ“ Missing values:", sum(is.na(x)), "\n")
  cat("ðŸ”¢ Unique categories:", length(unique(x)), "\n")
  
  if (show_plot) {
    cat("\nðŸ“Š Bar plot of top 10 categories:\n")
    print(
      data %>%
        filter(!is.na(!!var_sym)) %>%
        mutate(!!var_sym := forcats::fct_lump_n(!!var_sym, n = 10, other_level = "Other")) %>%
        ggplot(aes(x = !!var_sym)) +
        geom_bar(fill = "steelblue") +
        labs(title = paste("Top 10 Categories in", var_name),
             x = var_name, y = "Count") +
        theme_minimal() +
        coord_flip()
    )
  }
}

```
